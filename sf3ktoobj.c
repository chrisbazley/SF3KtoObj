/*
 *  SF3KtoObj - Converts Star Fighter 3000 graphics to Wavefront format
 *  Command-line parser
 *  Copyright (C) 2016 Christopher Bazley
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public Licence as published by
 *  the Free Software Foundation; either version 2 of the Licence, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public Licence for more details.
 *
 *  You should have received a copy of the GNU General Public Licence
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* ISO library header files */
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <errno.h>
#include <time.h>

/* StreamLib headers */
#include "ReaderGKey.h"
#include "ReaderRaw.h"

/* CBUtilLib headers */
#include "ArgUtils.h"
#include "StrExtra.h"
#include "StringBuff.h"

/* Local headers */
#include "sfformats.h"
#include "misc.h"
#include "flags.h"
#include "parser.h"
#include "version.h"

enum {
  HistoryLog2 = 9 /* Base 2 logarithm of the history size used by
                     the compression algorithm */
};

static bool process_file(_Optional const char * const input_file,
                         _Optional const char * const output_file,
                         const int first, const int last,
                         const SFObjectType type, _Optional const char * const name,
                         _Optional SFObjectColours * const pal, const int frame,
                         const char * const mtl_file,
                         const unsigned int flags, const bool time,
                         const bool raw)
{
  _Optional FILE *out = NULL, *in = NULL;
  bool success = true;

  assert(!(flags & ~FLAGS_ALL));

  if (input_file != NULL) {
    /* An explicit input file name was specified, so open it */
    if (flags & FLAGS_VERBOSE)
      printf("Opening input file '%s'\n", input_file);

    in = fopen(&*input_file, "rb");
    if (in == NULL) {
      fprintf(stderr, "Failed to open input file '%s': %s\n",
              input_file, strerror(errno));
      success = false;
    }
  } else {
    /* Default input is from standard input stream */
    fprintf(stderr, "Reading from stdin...\n");
    in = stdin;
  }

  if (success) {
    if (flags & (FLAGS_LIST|FLAGS_SUMMARY)) {
      out = NULL; /* No OBJ-format output */
    } else if (output_file != NULL) {
      if (flags & FLAGS_VERBOSE)
        printf("Opening output file '%s'\n", output_file);

      out = fopen(&*output_file, "w");
      if (out == NULL) {
        fprintf(stderr, "Failed to open output file '%s': %s\n",
                output_file, strerror(errno));
        success = false;
      }
    } else {
      /* Default output is to standard output stream */
      out = stdout;
    }
  }

  if (success && in) {
    const clock_t start_time = time ? clock() : 0;

    Reader r;
    if (raw) {
      reader_raw_init(&r, &*in);
    } else {
      success = reader_gkey_init(&r, HistoryLog2, &*in);
    }

    if (success) {
      success = sf3k_to_obj(&r, out, first, last, type, name,
                            pal, frame, mtl_file, flags);
      reader_destroy(&r);
    }

    if (success && time)
    {
      printf("Time taken: %.2f seconds\n",
             (double)(clock_t)(clock() - start_time) / CLOCKS_PER_SEC);
    }
  }

  if (in != NULL && in != stdin) {
    if (flags & FLAGS_VERBOSE)
      puts("Closing input file");
    fclose(&*in);
  }

  if (out != NULL && out != stdout) {
    if (flags & FLAGS_VERBOSE)
      puts("Closing output file");

    if (fclose(&*out)) {
      fprintf(stderr, "Failed to close output file '%s': %s\n",
                      output_file, strerror(errno));
      success = false;
    }
  }

  /* Delete malformed output unless debugging is enabled */
  if (!success && !(flags & FLAGS_VERBOSE) && out != NULL && out != stdout &&
      output_file) {
    remove(&*output_file);
  }

  return success;
}

static int syntax_msg(FILE * const f, const char * const path)
{
  assert(f != NULL);
  assert(path != NULL);

  const char * const leaf = strtail(path, PATH_SEPARATOR, 1);
  fprintf(f,
          "usage: %s [switches] [<input-file> [<output-file>]]\n"
          "or     %s -batch [switches] <file1> [<file2> .. <fileN>]\n"
          "If no input file is specified, it reads from stdin.\n"
          "If no output file is specified, it writes to stdout.\n"
          "In batch processing mode, output file names are generated by appending\n"
          "extension 'obj' to the input file names.\n"
          "If a material library file is specified then a reference to it will be\n"
          "inserted in the output. This file is not created, read or written.\n"
          "If a palette file is specified then it can be used to translate logical\n"
          "colour numbers into human-readable material names; otherwise, material\n"
          "names are logical colour numbers.\n",
          leaf, leaf);

  fputs("Switches (names may be abbreviated):\n"
        "  -help               Display this text\n"
        "  -batch              Process a batch of files (see above)\n"
        "  -list               List objects instead of converting them\n"
        "  -summary            Summarize objects instead of converting them\n"
        "  -index N            Object number to convert or list (default is all)\n"
        "  -first N            First object number to convert or list\n"
        "  -last N             Last object number to convert or list\n"
        "  -type G|B|S         Object type to convert or list (default is all)\n"
        "  -name <name>        Object name to convert or list (default is all)\n"
        "  -outfile <name>     Write output to the named file instead of stdout\n"
        "  -raw                Input is uncompressed raw data\n"
        "  -time               Show the total time for each file processed\n"
        "  -verbose or -debug  Emit debug information (and keep bad output)\n", f);

  fputs("Switches to customize the output:\n"
        "  -mtllib name        Specify a material library file (default sf3k.mtl)\n"
        "  -palette name       Specify a palette file in which to look up\n"
        "                      physical colours (default is none)\n"
        "  -frame N            Animation frame to convert (default is 0)\n"
        "  -false              Assign false colours for visualization\n"
        "  -human              Output readable material names (needs -palette)\n"
        "  -hidden             Include hidden polygons in the output\n"
        "  -unused             Include unused vertices in the output\n"
        "  -duplicate          Include duplicate vertices in the output\n"
        "  -negative           Output negative vertex indices\n"
        "  -clip               Clip overlapping coplanar polygons\n"
        "  -fans               Split complex polygons into triangle fans\n"
        "  -strips             Split complex polygons into triangle strips\n", f);

  return EXIT_FAILURE;
}

static _Optional SFObjectColours *load_palette(const char * const filename,
                                               const unsigned int flags,
                                               const bool raw)
{
  _Optional SFObjectColours *pal = NULL;

  if (flags & FLAGS_VERBOSE)
    printf("Opening palette file '%s'\n", filename);

  _Optional FILE * const palette = fopen(filename, "rb");
  if (palette == NULL) {
    fprintf(stderr, "Failed to open palette file: %s\n", strerror(errno));
  } else {
    pal = malloc(sizeof(SFObjectColours));
    if (pal == NULL) {
      fprintf(stderr, "Failed allocating memory for palette\n");
    } else {
      Reader p;
      bool success = true;

      if (raw) {
        reader_raw_init(&p, &*palette);
      } else {
        success = reader_gkey_init(&p, HistoryLog2, &*palette);
      }

      if (!success) {
        free(pal);
        pal = NULL;
      } else {
        if (reader_fread(&*pal, sizeof(SFObjectColours), 1, &p) != 1) {
          fprintf(stderr, "Failed to read palette\n");
          free(pal);
          pal = NULL;
        }
        reader_destroy(&p);
      }
    }

    if (flags & FLAGS_VERBOSE) {
      puts("Closing palette file");
    }

    fclose(&*palette);
  }

  return pal;
}

#ifdef FORTIFY
int real_main(int argc, const char *argv[]);

int main(int argc, const char *argv[])
{
  unsigned long limit;
  int rtn = EXIT_FAILURE;
  for (limit = 0; rtn != EXIT_SUCCESS; ++limit)
  {
    rewind(stdin);
    clearerr(stdout);
    printf("------ Allocation limit %ld ------\n", limit);
    Fortify_SetNumAllocationsLimit(limit);
    Fortify_EnterScope();
    rtn = real_main(argc, argv);
    Fortify_LeaveScope();
    Fortify_SetNumAllocationsLimit(ULONG_MAX);
  }
  return rtn;
}

int real_main(int argc, const char *argv[])
#else
int main(int argc, const char *argv[])
#endif
{
  int n, first = -1, last = -1, frame = 0;
  unsigned int flags = 0;
  _Optional const char *name = NULL;
  SFObjectType type = (SFObjectType)-1;
  bool time = false, batch = false, raw = false;
  int rtn = EXIT_SUCCESS;
  _Optional const char *output_file = NULL, *input_file = NULL, *palette_file = NULL;
  const char *mtl_file = "sf3k.mtl";
  _Optional SFObjectColours *pal = NULL;

  assert(argc > 0);
  assert(argv != NULL);

  DEBUG_SET_OUTPUT(DebugOutput_Reporter, "");

  /* Parse any options specified on the command line */
  for (n = 1; n < argc && argv[n][0] == '-'; n++) {
    const char *opt = argv[n] + 1;

    if (is_switch(opt, "batch", 1)) {
      /* Enable batch processing mode */
      batch = true;
    } else if (is_switch(opt, "clip", 1)) {
      /* Enable clipping of coplanar polygons */
      flags |= FLAGS_CLIP_POLYGONS;
    } else if (is_switch(opt, "debug", 2)) {
      /* Enable debugging output */
      flags |= FLAGS_VERBOSE;
    } else if (is_switch(opt, "duplicate", 2)) {
      /* Enable output of duplicate vertices */
      flags |= FLAGS_DUPLICATE;
    } else if (is_switch(opt, "false", 3)) {
      /* Enable false polygon colours */
      flags |= FLAGS_FALSE_COLOUR;
    } else if (is_switch(opt, "fans", 3)) {
      /* Enable decomposition of complex polygons into triangle fans */
      flags |= FLAGS_TRIANGLE_FANS;
    } else if (is_switch(opt, "first", 2)) {
      /* First object number to convert was specified */
      long int num;
      if (!get_long_arg("first", &num, 0, INT_MAX, argc, argv, ++n)) {
        return syntax_msg(stderr, argv[0]);
      }
      first = (int)num;
    } else if (is_switch(opt, "frame", 2)) {
      /* Object number to convert was specified */
      long int num;
      if (!get_long_arg("frame", &num, 0, INT_MAX, argc, argv, ++n)) {
        return syntax_msg(stderr, argv[0]);
      }
      frame = (int)num;
    } else if (is_switch(opt, "help", 2)) {
      /* Output usage information */
      (void)syntax_msg(stdout, argv[0]);
      return EXIT_SUCCESS;
    } else if (is_switch(opt, "hidden", 2)) {
      /* Enable output of hidden polygons */
      flags |= FLAGS_HIDDEN_POLYGONS;
    } else if (is_switch(opt, "human", 2)) {
      /* Enable human-readable material names */
      flags |= FLAGS_HUMAN_READABLE;
    } else if (is_switch(opt, "index", 1)) {
      /* Object number to convert was specified */
      long int num;
      if (!get_long_arg("index", &num, 0, INT_MAX, argc, argv, ++n)) {
        return syntax_msg(stderr, argv[0]);
      }
      first = last = (int)num;
    } else if (is_switch(opt, "last", 2)) {
      /* Last object number to convert was specified */
      long int num;
      if (!get_long_arg("last", &num, 0, INT_MAX, argc, argv, ++n)) {
        return syntax_msg(stderr, argv[0]);
      }
      last = (int)num;
    } else if (is_switch(opt, "list", 2)) {
      /* List contents of file */
      flags |= FLAGS_LIST;
    } else if (is_switch(opt, "mtllib", 1)) {
      /* Materials library file path was specified */
      if (++n >= argc || argv[n][0] == '-') {
        fputs("Missing materials library file name\n", stderr);
        return syntax_msg(stderr, argv[0]);
      }
      mtl_file = argv[n];
    } else if (is_switch(opt, "name", 2)) {
      /* Object name to convert was specified */
      if (++n >= argc || argv[n][0] == '-') {
         fputs("Missing object name\n", stderr);
         return syntax_msg(stderr, argv[0]);
      } else {
        name = argv[n];
      }
    } else if (is_switch(opt, "negative", 2)) {
      /* Enable negative vertex indices */
      flags |= FLAGS_NEGATIVE_INDICES;
    } else if (is_switch(opt, "outfile", 1)) {
      /* Output file path was specified */
      if (++n >= argc || argv[n][0] == '-') {
        fputs("Missing output file name\n", stderr);
        return syntax_msg(stderr, argv[0]);
      }
      output_file = argv[n];
    } else if (is_switch(opt, "palette", 1)) {
      /* Palette file path was specified */
      if (++n >= argc || argv[n][0] == '-') {
        fputs("Missing palette file name\n", stderr);
        return syntax_msg(stderr, argv[0]);
      }
      palette_file = argv[n];
      flags |= FLAGS_PHYSICAL_COLOUR;
    } else if (is_switch(opt, "raw", 1)) {
      /* Enable raw input */
      raw = true;
    } else if (is_switch(opt, "strips", 2)) {
      /* Enable decomposition of complex polygons into triangle strips */
      flags |= FLAGS_TRIANGLE_STRIPS;
    } else if (is_switch(opt, "summary", 2)) {
      /* List contents of file */
      flags |= FLAGS_SUMMARY;
    } else if (is_switch(opt, "time", 2)) {
      /* Enable timing */
      time = true;
    } else if (is_switch(opt, "type", 2)) {
      /* Object number to convert was specified */
      if (++n >= argc || argv[n][0] == '-') {
         fputs("Missing object type\n", stderr);
         return syntax_msg(stderr, argv[0]);
      } else {
        if (argv[n][1] == '\0') {
          switch (argv[n][0]) {
            case 'g':
            case 'G':
              type = SFObjectType_Ground;
              break;
            case 'b':
            case 'B':
              type = SFObjectType_Bit;
              break;
            case 's':
            case 'S':
              type = SFObjectType_Aerial;
              break;
          }
        }
        if (type == (SFObjectType)-1) {
          fputs("Bad object type\n", stderr);
          return syntax_msg(stderr, argv[0]);
        }
      }
    } else if (is_switch(opt, "unused", 1)) {
      /* Enable output of unused vertices */
      flags |= FLAGS_UNUSED;
    } else if (is_switch(opt, "verbose", 1)) {
      /* Enable debugging output */
      flags |= FLAGS_VERBOSE;
    } else {
      fprintf(stderr, "Unrecognised switch '%s'\n", opt);
      return syntax_msg(stderr, argv[0]);
    }
  }

  if ((first > last) && (last >= 0)) {
    fputs("First object number must not exceed last object number\n",
          stderr);
    return EXIT_FAILURE;
  }
  if (first == -1) {
    first = 0;
  }

  if ((flags & FLAGS_TRIANGLE_STRIPS) && (flags & FLAGS_TRIANGLE_FANS)) {
    fputs("Cannot split polygons into both triangle fans and strips\n",
          stderr);
    return EXIT_FAILURE;
  }

  /* We can only generate human-readable names from physical colours, not
     logical colours. */
  if ((flags & FLAGS_HUMAN_READABLE) && !(flags & FLAGS_PHYSICAL_COLOUR)) {
    fputs("Must specify a palette to enable -human\n", stderr);
    return EXIT_FAILURE;
  }

  if (batch) {
    if (output_file != NULL) {
      fputs("Cannot specify an output file in batch processing mode\n",
            stderr);
      return syntax_msg(stderr, argv[0]);
    }
    if (n >= argc) {
      fputs("Must specify file(s) in batch processing mode\n", stderr);
      return syntax_msg(stderr, argv[0]);
    }
  } else {
    /* If an input file was specified, it should follow the switches */
    if (n < argc) {
      input_file = argv[n++];
    }

    /* An output file name may follow the input file name, but only if not
       already specified */
    if (n < argc) {
      if (output_file != NULL) {
        fputs("Cannot specify more than one output file\n", stderr);
        return syntax_msg(stderr, argv[0]);
      }
      output_file = argv[n++];
    }

    if ((flags & (FLAGS_LIST|FLAGS_SUMMARY)) && (output_file != NULL)) {
      fputs("Cannot specify an output file in list or summary mode\n",
            stderr);
      return syntax_msg(stderr, argv[0]);
    }

    /* Ensure that OBJ output isn't mixed up with other text on stdout */
    if ((output_file == NULL) &&
        !(flags & (FLAGS_LIST|FLAGS_SUMMARY)) &&
        (time || (flags & FLAGS_VERBOSE))) {
      fputs("Must specify an output file in verbose/timer mode\n", stderr);
      return EXIT_FAILURE;
    }

    if (n < argc) {
      fputs("Too many arguments (did you intend -batch?)\n", stderr);
      return syntax_msg(stderr, argv[0]);
    }
  }

  if (flags & FLAGS_VERBOSE) {
    printf("Star Fighter 3000 to Wavefront obj convertor, "VERSION_STRING"\n"
           "Copyright (C) 2016, Christopher Bazley\n");
  }

  if (palette_file != NULL) {
    /* A palette file name was specified, so open it */
    pal = load_palette(&*palette_file, flags, raw);
    if (pal == NULL) {
      return EXIT_FAILURE;
    }
  }

  if (batch) {
    /* In batch processing mode, the remaining arguments are treated as a
       list of file names (output to default file names) */
    for (; n < argc && rtn == EXIT_SUCCESS; n++) {
      /* Invent an output file name */
      assert(argv[n] != NULL);
      StringBuffer default_output;
      stringbuffer_init(&default_output);
      if (!stringbuffer_append(&default_output, argv[n], SIZE_MAX) ||
          !stringbuffer_append_separated(&default_output, EXT_SEPARATOR,
                                         "obj")) {
        fprintf(stderr, "Failed to allocate memory for output file path\n");
        rtn = EXIT_FAILURE;
      } else if (!process_file(argv[n],
                               stringbuffer_get_pointer(&default_output),
                               first, last, type, name, pal, frame, mtl_file,
                               flags, time, raw)) {
        rtn = EXIT_FAILURE;
      }
      stringbuffer_destroy(&default_output);
    }
  } else if (!process_file(input_file, output_file, first, last, type,
                           name, pal, frame, mtl_file, flags, time, raw)) {
    rtn = EXIT_FAILURE;
  }

  free(pal);

  return rtn;
}
